---
title: 基础--盒模型
date: 2020-11-12
categories:
  - CSS
tags:
  - CSS
---

::: tip
:::

<!-- more -->

## 前言

盒模型是CSS中最重要的概念

## 盒模型

**盒模型**又名**框模型**，是一种网页设计思维模型，它把文档节点看成一个盒子。



在HTML文档解析过程中，每个节点都会描述为一个盒模型，然后一个盒模型套进另一个盒子中，再依据各个节点对应的CSS规则，最后渲染成一个井井有序的页面。

### 组成

**公式：`box = margin + border + padding + content`**



### 类型

由于历史原因，盒模型分为**标准盒模型**和**怪异盒模型（IE盒模型）**。可以通过CSS3设置：

+ 标准盒模型（默认）：`box-sizing: content-box`
+ 怪异盒模型：`box-sizing: border-box`



**标准盒模型**是W3C规范的标准，由`margin + border + padding + content`组成。

节点的尺寸计算公式如下：

+ **横向**：`margin-[left/right] + border-[left/right] + padding-[left/right] + width`

+ **纵向**：`margin-[top/bottom] + border-[top/bottom] + padding-[top/bottom] + height `

  

节点的高度计算公式如下：

+ **横向**：`width = width`

+ **纵向**：`height = height`

  

**怪异盒模型**又名 IE 盒子模型，是 IE 制定的标准

节点的尺寸计算公式如下：

+ **横向**：`margin-[left/right] + width`

+ **纵向**：`margin-[top/bottom] + height `

  

节点的高度计算公式如下：

+ **横向**：`width = border + padding + width
+ **纵向**：`height = border + padding + height`



**注意：在 ie 浏览器中，若 HTML 文档缺失 <!doctype html> 声明则会触发怪异盒模型**



## 视觉格式化模型

**盒模**型使用`display`的话会进化成视觉格式化模型

**视觉格式化模型**指在视觉媒体上处理和显示文档而使用得计算规则。它是一种CSS机制，由大量CSS规范组成，规定了节点在页面中的排版。

**块级元素**

当节点的`display`声明为block、list-item、table、flex或grid时，该节点被标记为块级元素。块级元素默认宽度默认为100%，在垂直方向向上按顺序放置，同时参与块格式化上下文。

每个块级元素都至少生成一个块级盒，或生成一块容器盒，块级盒描述它与兄弟节点间的表现方式，块容器盒描述它与子节点间的表现方式。

一个块容器盒只包含其他块级盒，或生成一个行内格式化上下文只包含行内盒。或许一段代码中某一个块容器盒同时包含块级盒和行内盒的情况，但实质上在这种情况下会产生一种新的匿名块盒解决该问题。



**行内元素**

当节点display声明为inline、inline-block、inline-table、inline-flex或inline-grid时，该节点被标记为行内元素。行内元素默认宽度为auto，在水平方向上按顺序放置，同时参与行内格式化上下文。

当行内级参与行内格式化上下文后变成行内盒。另外还有一个叫左匿名行内盒的概念，匿名行内盒与匿名块盒的原理类似，都是浏览器自动生成的补充性盒。



**两者区别**

+ 互相转换
  + 块级元素转换行内元素：`display:inline`
  + 行内元素转换块级元素：`display:block`
+ 展位表现
  + 块级元素默认独占一行，默认宽度为父元素的100%，可声明编剧、填充、宽高
  + 行内元素默认不独占一行，默认宽度随内容自动撑开，可声明水平编剧盒填充，不可声明垂直边距盒宽高
+ 包含关系
  + 块级元素可包含块级元素和行内元素
  + 行内元素可包含行内元素，不能包含块级元素



## 格式化上下文

**格式化上下文**指决定渲染区域里节点的排版、关系和相互作用的渲染规则。简单来说就是页面中有一个`ul`及其多个子节点`li`，格式化上下文决定这些`li`如何排版，`li`之间处于什么关系？

|      上下文      | 缩写 | 版本 |     声明     |
| :--------------: | :--: | :--: | :----------: |
| 块级格式化上下文 | BFC  |  2   | 块级盒子容器 |
| 行内格式化上下文 | IFC  |  2   | 行内盒子容器 |
| 弹性格式化上下文 | FFC  |  2   | 弹性盒子容器 |
| 格栅格式化上下文 | GFC  |  2   | 格栅盒子容器 |



**块级格式化上下文**

BFC是页面上一个独立且隔离的渲染区域，容器里的子节点不会在布局上影响到外面的节点，反之亦然。

规则：

+ 子节点在垂直方向上按顺序放置
+ 子节点的垂直方向距离有margin决定，相邻节点的margin会发生重叠，以最大margin为合并值
+ 每个节点的`margin-left/right`与父节点的`左边/右边`相接触，即使处于浮动也如此，除非自行形成BFC
+ BFC区域不会与同级浮动区域重叠
+ BFC是一个隔离且不受外界影响的独立容器
+ 计算BFC高度时其浮动子节点也参与计算

成因：

- 根节点：`html`
- 非溢出可见节点：`overflow:!visible`
- 浮动节点：`float:left/right`
- 绝对定位节点：`position:absolute/fixed`
- 被定义成块级的非块级节点：`display:inline-block/table-cell/table-caption/flex/inline-flex`
- 父节点与正常文档流的子节点(非浮动)自动形成BFC

场景：

- 清除浮动
- 已知宽度水平居中
- 防止浮动节点被覆盖
- 防止垂直margin合并

`margin塌陷`问题，可用BFC的概念回答了。所谓的塌陷其实是两个BFC的相邻盒或父子盒相互作用时产生的效果，两个盒子会取相邻边最大`margin`作为相邻边的共用`margin`。

`margin折叠`的计算问题：

- 两个盒子相邻边的`margin`都为正值，取最大值
- 两个盒子相邻边的`margin`都为负值，取最小值，两者会互相重合
- 两个盒子相邻边的`margin`一正一负，取两者相加值，若结果为负，两者会互相重合



行内格式化上下文

IFC的宽高由行内子元素中最大的实际高度确定，不受垂直方向的`margin`和`padding`影响。另外，IFC中不能存在块元素，若插入块元素则会产生对应个数的匿名块并互相隔离，即产生对应个数的IFC，每个IFC对外表现为块级元素，并垂直排列。

规则：

- 节点在水平方向上按顺序放置
- 节点无法指定宽高，其`margin`和`padding`在水平方向有效在垂直方向无效
- 节点在垂直方向上以不同形式对齐
- 节点的宽度由包含块和浮动决定，高度由行高决定

成因：

- 行内元素：`display:inline[-x]`
- 声明`line-height`
- 声明`vertical-align`
- 声明`font-size`



**弹性格式化上下文**

声明`display`为`flex`或`inline-flex`时，节点会生成一个`FFC`的独立容器，主要用于`响应式布局`。



##### 格栅格式化上下文

声明`display`为`grid`或`inline-grid`时，节点会生成一个`GFC`的独立容器，主要用于`响应式布局`。

细心的同学会发现，`GFC`有点像`<table>`，同为二维表格，但是`GFC`会有更丰富的属性控制行列、对齐以及更为精细的渲染语义和控制。不过由于兼容性不是特别好，所以笔者在本小册也不会讲解基于`GFC`的**格栅布局**。



## 文档流

**文档流**指节点在排版布局过程中默认使用从左往右从上往下的流式排列方式。在窗体自上而下分成一行行，且每行按照从左至右的顺序排列节点，其显著特点就是`从左往右从上往下`。

##### 类型

对于一个标准的文档流，可根据其特性对节点分类。

-  

  HTML级别

  -  容器级元素：`<div>`、`<ul>`、`<li>`等
  -  文本级元素：`<a>`、`<p>`、`<span>`等

-  

  CSS级别

  -  块级元素：`<div>`、`<ul>`、`<li>`等
  -  行内元素：`<a>`、`<p>`、`<span>`等

##### 微观现象

即使是标准的文档流，也不排除有一些小小的缺陷，笔者罗列三个常见缺陷。

-  **空白折叠**：HTML中换行编写行内元素，排版会出现`5px空隙`
-  **高矮不齐**：行内元素统一以底边垂直对齐
-  **自动换行**：排版若一行无法完成则换行接着排版

> 空白折叠解决方式

空白折叠也许是最容易出现的文档流微观现象，可能各位同学都会遇过。

```html
<ul>
    <li></li>
    <li></li>
    <li></li>
</ul>
ul {
    text-align: center;
}
li {
    display: inline-block;
}
```

此时，很多浏览器就会出现`5px空隙`，解决方式也有很多种的。

第一种，必须紧密连接节点。

```html
<ul>
    <li></li><li></li><li></li>
</ul>
```

第二种，子节点声明`margin-left:-5px`。

```css
li {
    display: inline-block;
    margin-left: -5px;
}
```

第三种，使用`Flex布局`居中显示。

```css
ul {
    display: flex;
    justify-content: center;
}
```

##### 脱流文档流

**脱流文档流**指节点脱流正常文档流后，在正常文档流中的其他节点将忽略该节点并填补其原先空间。文档一旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间，因此添加浮动或定位后会对周围节点布局产生或多或少的影响。

文档流的脱流有两种方式。

-  浮动布局：`float:left/right`
-  定位布局：`position:absolute/fixed`

> Float方式

节点使用`float`脱流时，会让其跳出正常文档流，其他节点会忽略该节点并填补其原先空间。但是该节点文本可不参与这个脱流效果，却会认同该节点所占据的空间并围绕它布局，这个就是常说的`文字环绕效果`的原理。

一句话概括：`节点参与浮动布局后，自身脱流但其文本不脱流`。

> Position方式

节点使用`position`脱流时(只有`absolute`和`fixed`)，会让其及其文本一起跳出正常文档流，其他节点会忽略该节点并填补其原先空间。`absolute`绝对定位是相对往上遍历第一个包含`position:relative`的祖先节点定位，若无此节点则相对`<body>`定位；`fixed`固定定位是相对浏览器窗口定位。

一句话概括：`节点参与定位布局后，自身及其文本一起脱流`。

##### 显隐影响

在正常文档流排版过程中，经常会使用`display:none`和`visibility:hidden`控制节点的隐藏，`display:none`简称`DN`，`visibility:hidden`简称`VH`。上一章有提及`DN`和`VH`的区别，这次看看节点切入隐藏状态后，会存在什么差别。

- 节点不可见但占据空间，显隐时可过渡：`visibility:hidden`
- 节点不可见但占据空间，不可点击：`visibility:hidden`
- 节点不可见不占据空间，可访问DOM：`display:none`
- 节点不可见但占据空间，可点击：`opacity:0`
- 节点不可见不占据空间，可点击：`position:absolute; opacity:0`
- 节点不可见但占据空间，不可点击：`position:relative; z-index:-1`
- 节点不可见不占据空间，不可点击：`position:absolute; z-index:-1`

